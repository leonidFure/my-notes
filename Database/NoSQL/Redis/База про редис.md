Redis (Remote Dictionary Server) — это высокопроизводительное хранилище данных в памяти (in-memory), работающее по принципу ключ-значение. Он используется для кэширования, распределённых блокировок, очередей сообщений и даже в качестве основной базы данных в высоконагруженных системах.
Отлично! Давай глубже разберёмся в возможностях Redis и его применении.
### Типы данных и их использование

Redis поддерживает множество структур данных, которые можно использовать для разных сценариев:

|Тип данных|Описание|Применение|
|---|---|---|
|**String** (Строки)|Простые строки до 512MB|✅ Кэширование объектов, ✅ Токены|
|**List** (Списки)|Последовательность значений|✅ Очереди, ✅ Ленты событий|
|**Hash** (Хэши)|Набор полей и значений|✅ Профили пользователей|
|**Set** (Множества)|Уникальные элементы|✅ Теги, ✅ Чёрные списки|
|**Sorted Set** (Упорядоченные множества)|Множество с приоритетом|✅ Рейтинги, ✅ Очереди с приоритетами|
|**Bitmap**|Хранение битов (0/1)|✅ Статистика активности|
|**HyperLogLog**|Приблизительный подсчёт уникальных элементов|✅ Аналитика (уникальные пользователи)|
|**Streams**|Лог записей (Kafka-подобная структура)|✅ Логирование событий, ✅ Очереди|
### Персистентность (хранение на диск)

Redis работает в оперативной памяти, но может сохранять данные на диск:
- **RDB (Redis Database Backup)** – снимки данных через определённые интервалы (`SAVE`, `BGSAVE`).
- **AOF (Append Only File)** – запись всех команд в лог (более надёжно).
- **Гибридный режим** – комбинация RDB + AOF.
**Когда использовать что?**  
- RDB – быстрее, но можно потерять данные при сбое.  
- AOF – медленнее, но сохраняет все операции.
### Репликация и отказоустойчивость
Redis поддерживает:
- Master-Slave** репликацию (основной узел и копии для чтения).
-  **Redis Sentinel** – автоматическое переключение в случае падения мастера.
-  **Redis Cluster** – горизонтальное масштабирование (шардирование).
Если нужна отказоустойчивость, стоит смотреть в сторону **Redis Sentinel** или **Redis Cluster**.
### Масштабирование
Redis можно горизонтально масштабировать с помощью:
- **Sentinel** – репликация + автоматический failover.
- **Cluster** – распределение ключей по нодам.
- **Sharding** – ручное разбиение данных.
Для кэширования обычно используют **рефликативный Redis**, а для хранения большого объёма данных – **кластерный Redis**.
### Pub/Sub (мессенджинг)
Redis можно использовать как брокер сообщений через **Publish/Subscribe**:
- **Publisher** отправляет сообщение в канал.
- **Subscribers** слушают этот канал и получают обновления.
Это полезно для: 
-  Чата, 
-  Уведомлений, 
-  Обмена событиями между микросервисами.
Пример команд:

```shell
PUBLISH news "Breaking news!"
SUBSCRIBE news
```
### Lua-скрипты
Redis поддерживает **скрипты на Lua**, что позволяет:
- Выполнять сложные операции атомарно.
- Избегать гонок данных.
- Минимизировать сетевые вызовы.
Пример:
```lua
redis.call('SET', 'counter', 1)
redis.call('INCR', 'counter')
return redis.call('GET', 'counter')
```
Вызов в CLI:
```shell
EVAL "return redis.call('GET', 'counter')" 0
```
### Redis для аналитики
Redis поддерживает:
- **Bitmaps** – трекинг активности (например, логин пользователя за месяц).
- **HyperLogLog** – оценка количества уникальных пользователей (`PFCOUNT`).
- **Geo API** – хранение и поиск геопозиций (`GEOADD`, `GEODIST`, `GEORADIUS`).
Пример работы с геоданными:
```shell
GEOADD cities 13.4050 52.5200 "Berlin"
GEOADD cities 2.3522 48.8566 "Paris"
GEODIST cities Berlin Paris km
```
## Когда Redis – отличный выбор?
- Кэширование (сессии, данные API).  
- Очереди и брокер сообщений.  
- Отказоустойчивая репликация (Sentinel, Cluster).  
- Аналитика (битмапы, HyperLogLog).  
- Геолокационные данные.  
- Быстрый поиск в наборах данных.
 **Когда не стоит использовать Redis?**
- Если данные **должны храниться навсегда** (Redis – это in-memory хранилище).
- Если нужна **сложная реляционная логика** (Redis не заменит SQL).
- Если **память ограничена** (Redis требует много RAM).