1. Single Responsibility Principle (SPR)
	- Класс должен иметь только одну причину для изменения (одну ответственность).
	- От себя: объект не должен управлять созданием других объектов; если это сервис с бизнес логикой, он не должен работать с базами данных, http ресурсами и тд. Например, если мы решили поменять запрос для получение заказов, мы не должны делать изменения в классе Service, изменения должны быть только в классе, ответственном за взаимодействие с БД (Repository).
2. Open/Close Principle (OCP)
	- Классы должны быть открыты для расширения, но закрыты для модификации.
	- От себя: например у нас есть обработка заявок с двумя типами, и потребовалось добавить новый тип. Код должен быть таким, чтобы нам не нужно было прописывать новые условные блоки, достаточно было бы добавить новый вариант стратегии для работы с новым типом заказов.
3. Liskov Substitution Principle (LSP)
	- Объекты подклассов должны быть заменяемы объектами суперклассов без нарушения поведения программы.
	- От себя: логика класса наследника не должна в корне менять логику родительского класса. Есть у нас ArrayList, мы делаем его наследника, не должно быть так, что у наследника метод добавления элемента, например, удаляет все элементы из коллекции.
4. Interface Segregation Principle (ISP)
	- Интерфейсы должны быть узкоспециализироваными, а не общими.
	- От себя: есть логика отправки уведомлений, есть интерфейс с набором методов отправки push, sms, email нотификаций. У него есть наследник, который реализует только отправку sms, ему не нужна реализация других методов. Чтобы такого не было, лучше разбить на разные интерфейсы логику (PushNotification, SmsNotification, EmailNotification), и в классе наследнике имплементировать только нужную логику.
5. Dependency Inversion Principle (DIP)
	- Модули высокого уровня не должны зависеть от модулей низкого уровня; оба должны зависеть от абстракций.
	- От себя: например у нас есть пачка стратегий для реализации формирования отчетов. Есть абстрактный класс, в который внедряется класс формирования xlsx файлов. После реализации нам понадобилось добавить стратегию с формированием отчета в формате pdf, у нас возникают проблемы, т.к. класс от которого мы наследуемся жестко завязан на формировании отчетов в формате xlsx. Лучше внедрять сервис формирования файла через интерфейс, а реализацию определять в классах наследниках. 