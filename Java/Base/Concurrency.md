# Основы многопоточности
В Java многопоточность основана на использовании классов и интерфейсов из пакета `java.lang` и `java.util.concurrent`.
- Поток - независимая последовательность выполнения.
- Runnable - интерфейс для описания задачи, которая может быть выполнена в потоке.
Пример создания потока:
```java
public static void main(String[] args) {
	final var thread = new Thread(() -> {
		System.out.println("Hello word");
	});
}
```
# Основные проблемы многопоточности
- Race Condition: возникает, когда несколько потоков пытаются одновременно изменить общие данные.
- Deadlock: Потоки блокируют друг друга, ожидая освобождения ресурсов.
- Livelock: Потоки продолжают взаимодействовать, но не могут прогрессировать.
- Starvation: Поток не получает доступ к ресурсу из-за других потоков с более высоким приоритетом.
# Механизмы синхронизации
### Ключевое слово synchonized
- Используется для блокировки метода или блока кода.
- Гарантирует, что только один поток может выполнить код в определенный момент времени;
### ReetrantLock
Более гибкая альтернатива `synchronized`. Позволяет:

- Устанавливать таймаут на ожидание блокировки.
- Проверять состояние блокировки.
```java
Lock lock = new ReentrantLock();
public void increment() {
    lock.lock();
    try {
        counter++;
    } finally {
        lock.unlock();
    }
}
```
### valotile
- **Гарантия видимости:**  
    При записи в `volatile` переменную, измененное значение немедленно записывается в основную память (main memory), а при чтении всегда берется из основной памяти.
    
- **Запрет переупорядочивания:**  
    JMM запрещает компилятору и процессору менять порядок операций относительно `volatile` переменной. Это предотвращает некоторые ошибки при многопоточности.
# Атомарность
Операция атомарна, если невозможно наблюдать частичный результат ее выполнения. Любой наблюдатель видит либо состояние системы до атомарной операции, либо после.
В Java:
- запись в поле типа boolean, byte, short, char, int, Object всегда атомарна.
- запись в поле типа long/double: атомарна запись старших и младших 32 бит
- запись в поле типа long/double, объявленное valotile, атомарна.
**Арифметические операции не атомарны!**
# Видимость (visibility)
- результат операции записи X, выполненной в потоке А, виден в операции чтения X, выполненной в потоке B.
- видимость определена только для конкретных потоков A и B, нет глобальной видимости.
# Порядок (ordering)
- A happens before B (A hb B), если все записи, выполненные до точки  A (включительно), видны в любой операции чтения после точки B (включительно).
- A hb B, B hb C -> A hb C
- Для двух операций A и B в одном потоке A hb B, если A раньше B в тексте программы (program order).
- Завершение конструктора объекта X hb начало finalize X.
- Вызов thread.start() hb первое действие в потоке thread.
- Последнее действие в потоке thread hb thread.join().
- Инициализация объекта по умолчанию hb любое другое действие.
# Механизмы из concurrent
- CountDownLatch
- Semaphore
- Exchanger
- CyclicBarrier
- Phaser