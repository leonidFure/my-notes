## publishOn
Позволяет перенести **этап выполнения** потока данных в конкретный **рабочий поток**.
Под капотом у оператора есть очередь, куда записываются новые элементы, чтобы выделенный рабочий поток мог последовательно извлекать сообщения и обрабатывать их.
```java
// медленные процессы (4-5-6) не будут блокировать обработку последующих элементов
// для этапов (1-2)
// не было бы этого, второй элемент не вступил бы в работу, пока полностью не
// выолнится первый
Flux.just(1, 2, 3)  
        .map(it -> "el: " + it)  // 1
        .doOnNext(System.out::println) // 2 
        .publishOn(Schedulers.boundedElastic()) // 3 
        .delayElements(Duration.ofMillis(1200))  // 4
        .map(it -> "after delay " + it)  // 5
        .doOnNext(System.out::println)  // 6
        .blockLast();
```
## subscribeOn
Позволяет изменить рабочий поток выполнения в котором выполняется часть цепочки, относящаяся к подписке. Этот оператор может пригодиться для создания источника данных, основанного на применении функции. Обычно в таких случаях данные генерируются на этапе подписки, поэтому и сами функции вызываются в момент вызова метода `.subscribe()`
Оператор subscribeOn в какой-то мере может определять рабочий поток для этапа выполнения наряду с рабочим потоком для этапа подписки. Это возможно, потому что наряду с планированием выполнения метода subscribe он планирует каждый вызов метода Subscription.request(), то есть это происходит в рабочем потоке выполнения, который определит экземпляр Scheduler.
## parallel
Позволяет разбить один поток данных на несколько подпотоков и распределить элементы между ними. .`parallel()` является частью Flux API. После применения оператора `parallel` мы начинаем работать с другим типом Flux – ParallelFlux. **ParallelFlux** – это абстракция группы экземпляров Flux, между которыми распределяются элементы из исходного потока Flux. Затем, применив оператор `runOn`, можно применить **publishOn** к внутренним экземплярам Flux и распределить работу по обработке элементов между несколькими рабочими потоками.
```java
Flux.range(0, 10000)
	.parallel() 
	.runOn(Schedulers.parallel()) 
	.map() 
	.filter() 
	.subscribe()
```
