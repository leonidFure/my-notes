# Основные понятия
## Шаблон "Наблюдатель"
В шаблон "**Наблюдатель"** входит объект, который хранит список своих наблюдателей. Объект уведомляет наблюдателей обо всех изменениях в своем состоянии, вызывая один из их методов. Шаблон "Наблюдатель" позволяет регистрировать зависимости "один ко многим" между объектами в процессе выполнения. В тоже время он ничего не знает о тонкостях реализации компонента-подписчика.
![[Pasted image 20240202232103.png]]
# RxJava как реактивный фреймворк
Библиотека **RxJava**. - это реализация реактивных расширений Reactive Extensions в JavaVM. Reactive Extensions - набор инструментов, позволяющих императивным языкам работать с потоками данных не зависимо от того , какая у них природа: синхронная и асинхронная.
## Интерфейс Observer
Интерфейс **Observer** определяет порядок передачи данных между частями реактивного потока.
```java
public interface RxObserver<T> {
	void onNext(T next);
	void onComplete();
	void onError();
}
```
## Класс Observable
Реактивный класс **Observable** является аналогом **Subject** из шаблона **"Наблюдатель"**. Как следствие **Observable** играет роль источника событий.
## Класс Subscriber
Абстрактный класс **Subscriber** реализует интерфейс **Observer** и потребляет события. Он также используется как базовый класс для фактической реализации подписчика.
## Основная логика взаимодействия Observable и Subscriber 
Отношения между  **Observable** и **Subscriber** регламентируются реализацией подписки Subscription, которая позволяет проверить состояние подписки и отменять ее при необходимости.
![[Pasted image 20240206133032.png]]
Источнику Observable разрешено отправить любое число (в том числе ноль) событий (`onNext()` для каждого подключенного клиента). Затем он должен сигнализировать об окончании выполнения, послав либо признак успешного завершения (`onComplete()`), либо ошибку (`onError()`). Вызывать `onNext()` после `onComplete()` или `onError()` запрещено. 
Пример простой реактивной логики с использованием **RxJava**:
```java
Observable.create(emitter -> {  
          emitter.onNext("Hello word");  
          emitter.onComplete();  
       })  
       .subscribe(System.out::println,  
             e -> System.out.println("ERROR: " + e),  
             () -> System.out.println("DONE!"));
```
## Интерфейс Subscription
Интерфейс **Subscription** позволяет управлять взаимодействием **Observer** и **Subscriber**.
```java
interface Subscription {
	void unsubscribe();
	boolean isSubscribed();
}
```
###  Преобразование потоков и диаграммы Marble
###  Оператор map
```java
<R> Observable<R> map(Func1<T, R> func);
```
Функция `func` может преобразовывать объекты типа `T` в тип `R`.![[Pasted image 20240206140420.png]]
Оператор Map  преобразует элементы потока, отправляемые экземпляром Observable, применяю к каждому указанную функцию.
### Оператор filter
Отправляет дальше только те элементы, которые прошли проверку предиката. 
![[Pasted image 20240206140802.png]]
### Оператор count
Отправляет дальше число элементов во входном потоке. Отправка числа оператором count произойдет в тот момент, когда исходный поток закончится.
![[Pasted image 20240206140958.png]]
### Оператор zip
Объединяет элементы из двух параллельных потоков, применяя функцию `zip`. Часто используется для обогащения данных, особенно когда две части результата извлекаются из разных источников.
![[Pasted image 20240206141356.png]]
Объединяет несколько потоков с помощью указанной функции и для каждой комбинации посылает единственный элемент - результат этой функции.
```java
Observable.zip(
	Observable.just("A", "B", "C"),
	Observable.just("1", "2", "3"),
	(x, y) -> x + y
).forEach(System.out::println)
// в результате будет A1, B2, C3
```

[Операторы, использующиеся в реактивном программировании](https://rxmarbles.com/)
# Reactive Streams -  новый стандарт потоков
## Проблема управления потоками данных
В реактивном программировании используется PUSH модель передачи данных, и если производитель не будет учитывать возможностей потребителя, появятся последствия для стабильности всей системы.
### Медленный производитель, быстрый потребитель
Такая ситуация может возникнуть из-за недостатка точности информации о потребителе на стороне производителя. ДЛя решения проблемы важно правильно определить фактическую скорость потребления.
### Быстрый производитель, медленный потребитель
Проблема заключается в том, что производитель может послать намного больше данных, чем потребитель в состоянии обработать, что может вызвать отказ компонента и катастрофические последствия.
Одно из очевидных решений - складывание поступающих элементов в очередь, либо где-то между потребителем и производителем, либо на стороне потребителя.
Но для этого необходимо выбрать очередь, очереди делятся на 3 общих типа:
#### Неограниченная очередь
Все производимые элементы складываются в очередь, затем извлекаются фактическим подписчиком. 
Преимущество - гарантия доставки всех сообщений, рано или поздно будут обработаны все сообщения.
Недостаток - ресурсы системы ограничены, из-за чего снижается устойчивость приложения.
![[Pasted image 20240206172004.png]] 
#### Ограниченная очередь со сбором избыточных элементов
После заполнения будет игнорировать входящие сообщения. Это решение учитывает ограниченность ресурсов и позволяет настраивать емкость очереди, очереди такого типа используют, когда важность сообщений низка.![[Pasted image 20240206172450.png]]
#### Ограниченная очередь с блокировкой
Очереди с возможностью блокировки производителя.
![[Pasted image 20240206173025.png]]Такой подход лишает систему преимуществ асинхронной обработки, а так же снижает эффективность использования ресурсов.
Следовательно, ни одно из перечисленных решений не удовлетворяет сразу всем 3-м характеристикам: устойчивость, эластичность и отзывчивость. 
## Основные положения стандарта Reactive Streams
Стандарт Reactive Streams определяет четыре основных интерфейса: `Publisher`,  `Subscriber`, `Subscription`, `Processor`.
**Publisher** -  издатель/источник событий. Имеет один метод - точку для создания связи между издателем `Publisher` и подписчиком `Subscriber`.
```java
public interface Publisher<T> {
	void subscribe(Subscriber<? super T> s);
}
```
**Subscriber** - подписчик, определяет порядок передачи данных между частями реактивного потока, аналогично `Observer`.
```java
public interface Subscriber<T> {
	void onSubscribe(Subscription s); // подписка
	void onNext(T next); // новое событие
	void onError(Throwable t); // ошибка
	void onComplete(); // завершение подписки
}
```
**Subscription** - контракт, определяет основу для управления производством элементов. Имеет метод `cancel()`, для отмены подписки на поток или публикации событий в целом. Метод `request(long n)` позволяет подписчику сообщить издателю **Publisher**, сколько данных тот должен послать, передав аргумент в вызов метода request, и быть уверенным, что число входящих элементов не превысит ограничения. 
```java
public interface Subscription {
	void request(long n);
	void canncel();
}
```
![[Pasted image 20240206220832.png]]Издатель **Publisher** гарантирует, что новая порция данных будет отправлена только в ответ на запрос подписчика **Subscriber**.
Помимо простой модели PUSH стандарт предлагает гибридную модель PUSH-PULL, которая поддерживает возможность управления обратным давлением.
Чтобы получить чистую PULL модель - запрашивать 1 элемент в каждом вызове `Subscriber#onNext`.
Чтобы получить чистую PUSH модель - запрашивать `Long.MAX_VALUE`.
Чтобы получить чистую PULL модель - запрашивать 1 элемент в каждом вызове `onNext()`. 
Чтобы получить PUSH-PULL модель - запрашивать необходимое количество элементов, и,  если необходимо во время вызова `Subscriber#onNext` дополнительно запрашивать еще порцию элементов (PUSH-PULL - гибкая модель взаимодействия, для поддержки обратного давления).
**Processor** - комбинация `Publisher` и `Subscriber`, предназначен для выполнения некоторых этапов обработки между Publisher и Subscriber.
```java
public interface Proccessor<T, R> extends Subscriber<T>, Publisher<R> {}
```
![[Pasted image 20240207134133.png]]
В этом примере процесс разбит на 4 компонента:
- `DbPublisher` отвечает за извлечение данных из БД.
- `NewsPreparationOperator` выполняет промежуточные преобразования, объединяет полученные данные, затем, когда от основного источника поступит сигнал о завершении компонует данные.
- `ScheduledPublisher` отвечает за планирование периодических задач.
- `SmartMulticastProcessor` кэширует последние данные, кроме того он поддерживает многоадресную рассылку, а значит нет необходимости создавать один и тот же поток для каждого потребителя. 
- Фактические потребители.
Когда необходимо простое преобразование из A в B, нет необходимости использовать интерфейс, одновременно представляющий Subscriber и `Publisher`. Присутствие интерфейса Subscriber означает, что после того как реализация Processor подпишется на вышестоящий поток, элементы будут поступать в метод `Subscriber#onNext` и теоретически могут теряться из-за отсутствия нижестоящего подписчика `Subscriber`. Поэтому при использовании такого подхода необходимо подписаться на `Processor` до того, как Processor подпишется на основного издателя.
# Project Reactor - основа реактивных приложений
## Основы Project Reactor
`Flux` и `Mono` - реализации интерфейса `Publisher<T>`.
**Flux** - определяет поток данных, который может вернуть 0..N элементов.
![[Pasted image 20240207154705.png]]
Простой бесконечный поток данных:
```java
Flux.range(1, 5).repeat();
```
Данный поток бесконечно производит числа от 1 до 5, но не представляет никакой проблемы, не переполнит память, потому что для получения каждого элемента не требуется заранее генерировать всю последовательность целиком. Кроме того подписчик может в любой момент отменить подписку и превратить бесконечный поток в конечный.
**Mono** - определяет поток данных, который может вернуть 0..1 элементов. Mono ничего не делает до создания подписки
![[Pasted image 20240207155259.png]]
## Создание последовательностей Flux и Mono
```java
Flux<String> stream0 = Flux.just("hello", "word");  
Flux<String> stream1 = Flux.fromArray(new String[]{"hello", "word"});  
Flux<String> stream2 = Flux.fromIterable(Arrays.asList("hello", "word"));  
Flux<Integer> stream3 = Flux.range(2023, 9);  
Mono<String> stream4 = Mono.just("hello");  
Mono<Object> stream5 = Mono.justOrEmpty(null);  
Mono<Object> stream6 = Mono.justOrEmpty(Optional.empty()); 
Mono<String> stream7 = Mono.fromCallable(() -> request()); 
Flux<Object> stream8 = Flux.empty();  
Flux<Object> stream9 = Flux.never();  
```
Фабричный метод `error(Throwable)` создает последовательность, которая передает ошибку через вызов метода `onError()` каждому подписчику, когда тот подпишется. Ошибка создается при определении экземпляра `Flux` или `Mono`, и соответственно каждый подписчик получит один и тот же экземпляр Throwable.
```java
Flux<Object> stream10 = Flux.error(new RuntimeException("error"));
```
Фабричный метод `defer` создает последовательность, которая определяет свое поведение в момент подписки, и соответсвенно может генерировать разные данные для разных подписчиков.
```java
// проверка isValid будет вызвана только при подписке
// на поток
public Mono<User> requestUserDataDefer(String id) {
	return Mono.defer(() -> isValid(id)
		? Mono.fromCallable(() -> request())
		: Mono.error(new RunTimeException("error")));
}

// проверка isValid будет произведена когда будет 
// вызван метод requestUserData
public Mono<User> requestUserData(String id) {
	return isValid(id)
		? Mono.fromCallable(() -> request())
		: Mono.error(new RunTimeException("error")));
}

```
## Подписка на реактивный поток
Flux и Mono предлагают перегруженные лямбда-версии метода subscribe(), который упрощает процедуру подписки:
```java
// 1
subscribe();
// 2
subscribe(Consumer<T> dataConsumer);
// 3
subscribe(Consumer<T> dataConsumer, Consumer<Throwable> errorConsumer);
// 4
subscribe(Consumer<T> dataConsumer, Consumer<Throwable> errorConsumer, Runnable completeConsumer);
// 5
subscriber(Consumer<T> dataConsumer, Consumer<Throwable> errorConsumer, Runnable completeConsumer, Consumer<SubscriptionConsumer>);
// 6
subscribe(Subscriber<T> subscriber);
```
Все перегруженные версии метода subscribe возвращают экземпляр интерфейса Disposable.  Это можно использовать для отмены подписки Subscription. В случаях 1-4 метод subscribe запрашивает неограниченное число элементов.
1. Это самый простой способ подписаться на поток данных, так как метод игнорирует любые типы сигналов. 
2. Для каждого значения вызывает dataConsumer (сигнал `onNext`). Эта версия не обрабатывает сигналы onError и onComplete.
3. Действует аналогично (2), но так же обрабатывает сигналы `onError`.
4. Действует аналогично (3), но так же обрабатывает сигналы `onComplete`.
5. Позволяет получить все элементы реактивного потока. Дает возможность управлять подпиской путем запроса требуемого объема данных.
6. Самый обобщенный способ подписки. Здесь можно передать свою реализацию подписчика `Subscriber` с желаемым поведением. Но, не смотря на универсальность этого варианта, он редко используется на практике.
Для отмены подписки можно использовать `Disposable`:
```java
Disposable disposable = Flux.interval(Duration.ofMillis(50))
	.subscribe(data -> log.info("onNext: {}", data));
Thread.sleep(200);
disposable.dispose();
```
Так же для отменять подписку можно через вызов метода `Subscription#cancel`:
```java
Flux.range(1, 100)
	.subscribe(
		data -> log.info("onNext: {}", data),
		err -> log.error("onError: {}", e.getMessage),
		() -> log.info("onComplete"),
		subscription -> {
			subscription.request(4); // запрашиваем 4 элемента
			subscription.cancel(); // отменяем подписку
		}
	);
```
При отмене подписки событие `onComplete` не будет вызвано.
## Своя реализация Subscriber
```java
private final Subscriber<String> subscriber = new Subscriber<>() {  
    private volatile Subscription subscription;  
  
    @Override  
    public void onSubscribe(Subscription s) {  
       this.subscription = s;  
       log.info("initial request for 1 element");  
       this.subscription.request(1);  
    }  
  
    @Override  
    public void onNext(String string) {  
       log.info("onNext: {}", string);  
       log.info("initial request for 1 element");  
       this.subscription.request(1);  
    }  
  
    @Override  
    public void onError(Throwable t) {  
       log.error("onError: {}", t.getMessage());  
    }  
  
    @Override  
    public void onComplete() {  
       log.info("onComplete");  
    }  
};

Flux.just("hello", "word")  
       .subscribe(subscriber);
// выводимый результат
// initial request for 1 element
// onNext: hello
// initial request for 1 element
// onNext: word
// initial request for 1 element
// onComplete
```
Здесь описан не правильный подход к определению подписки. Он рушит линейность кода и способствует появлению ошибок. Чтобы избежать проблем рекомендуется расширять класс `BaseSubscriber` из библиотеки Project Reactor.
```java
private final Subscriber<String> subscriber1 = new BaseSubscriber<String>() {  
    @Override  
    protected void hookOnSubscribe(Subscription subscription) {  
       log.info("initial request for 1 element");  
       super.request(1);  
    }  
  
    @Override  
    protected void hookOnNext(String value) {  
       log.info("onNext: {}", value);  
       log.info("initial request for 1 element");  
       super.request(1);  
    }  
};
```
## Преобразование реактивных последовательностей с помощью операторов
### Отображение элементов реактивных последовательностей

| Оператор             | Описание                                                                                                             |
| -------------------- | -------------------------------------------------------------------------------------------------------------------- |
| map(Function<T, R>)  | Позволяет обрабатывать элементы по одному, из-за смены типа элемента, вся последовательность так же меняет свой тип. |
| cast(Class<E> clazz) | Преобразует элементы из потока данных в целевой класс.                                                               |
| index()              | Позволяет присвоить индексы элементам последовательности.                                                            |
### Фильтрация реактивных последовательностей

| Оператор             | Описание                                                                                                                                                               |
| -------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| filter               | Пропускает только элементы, удовлетворяющие заданному условию.                                                                                                         |
| ignoreElements       | Возвращает Mono<T> и отфильтровывает все элементы. Получившаяся в результате последовательность завершается, только когда завершается оригинальная последовательность. |
| take(n)              | Игнорирует все элементы, кроме n первых.                                                                                                                               |
| takeLast             | Возвращает только последний элемент из потока данных.                                                                                                                  |
| takeUntil(Predicate) | пропускает элементы, пока не выполнится заданное условие.                                                                                                              |
| elementAt(n)         | Пропускает только n-й элемент.                                                                                                                                         |
| single               | Передает единственный элемент от источника и сигнализирует ошибкой NoSuchElementException, если источник пуст, и IndexOutOfBoundsException, если источник передаст больше одного элемента.                                                                                                                                                                       |
Кроме того, поддерживается возможность перепрыгивать через элементы или извлекать их, ориентируясь на продолжительность Duration, используя операторы `skip(Duration)` и `take(Duration)`.
Также перепрыгивать через элементы или извлекать их можно до момента получения некоего сообщения из другого потока данных, используя операторы `takeUntilOther(Publisher)` и `skipUntilOther(Publisher)`.
![[Pasted image 20240207200657.png]]
### Сбор данных из реактивной последовательности

| Метод                                                                                                                    | Описание                                                                                                                                                                                 |
| ------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Flux.collectList()<br>Flux.collectSortedList()<br>Flux.collectMap()<br>Flux.collectMultiMap()<br>Flux.collect(Collector) | Позволяют собрать элементы потока в необходимую коллекцию.                                                                                                                               |
| repeat<br>repeat(times)                                                                                                  | Позволяет организовать цикл по входящим последовательностям.                                                                                                                             |
| defaultIfEmpty(T)                                                                                                        | Предоставляет значения по умолчанию в пустые Flux и Mono.                                                                                                                                |
| Flux.distinct()                                                                                                          | Пропускает только элементы, не встречавшиеся в потоке прежде. Метод хранит все уникальные значения, из-за чего могут возникнуть проблемы при обработки потоков данных большой мощьности. |
| Flux.distinctUntilChanged()                                                                                              | Может использоваться с бесконечными потоками для устранения дубликатов, следующих друг за другом.                                                                                                                                                                                         |
![[Pasted image 20240207201705.png]]
### Сокращение элементов потока

| Метод               | Описание                                                                                                                                  |
| ------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| count()             | Считает число элементов в потоке.                                                                                                         |
| Flux.all(Predicate) | Проверяет, все ли элементы подходят под условие.                                                                                          |
| Flux.any(Predicate) | Проверяет, есть ли хотя бы один элемент, подходящий под условие.                                                                          |
| hasElements         | Проверяет, есть ли в потоке элементов.                                                                                                    |
| hasElement(T)       | Проверяет, есть в ли в потоке конкретный элемент.                                                                                         |
| sort                | Сортирует элементы в фоновом режиме и посылает отсортированную последовательность, как только оригинальная последовательность завершится. |
| reduce              | Объединяет значения из последовательности и возвращает Mono.                                                                              |
| scan                | Объединяет значения из последовательности, возвращая поток промежуточных результатов.                                                     |
| then<br>thenMany<br>thenEmpty                    | Игнорируют входящие элементы и воспроизводят только сигналы завершения и ошибки. Используется для запуска новых потоков по завершению предыдущих.                                                                                                                                          |
### Комбинирование реактивных потоков

| Метод  | Описание                                                                                                                                                               |
| ------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| concat | Объединяет все источники, пересылая полученные элементы дальше. При объединении двух потоков сначала считываются элементы из первого потока, потом из второго.         |
| merge  | Сливает данные из входящих потоков в одну исходящую последовательность. Данные из входящих потоков потребляются одновременно и могут чередоваться в нисходящем потоке. |
| zip    | Подписывается на все входящие потоки, ждет когда они все пришлют по одному элементу, группирует их в один исходящий элемент.                                           |
| combineLatest       | Подписывается на все входящие потоки, начинает генерировать новые значения, как только получит хотя бы один элемент из входящей последовательности.                                                                                                                                                                       |
### Пакетная обработка элементов потока

Библиотека Project Reactor поддерживает несколько методов пакетной обработки элементов (`Flux<T>`):
- буферизация элементов в контейнеры (`Flux<List<T>>`)
- кадрирование элементов в поток потоков (`Flux<Flux<T>>`)
- группировка элементов по ключу (`Flux<GroupedFlux<K, T>>`)
Буферизацию и кадрирование можно организовать следующим образом:
- по количеству обрабатываемых элементов (для каждых 10 элементов)
- по интервалу времени (для каждого 5-минутного интервала)
- по условию (по каждому новому четному числу)
- по событию, поступившему из другого потока Flux

```java
Flux.range(1, 13)
	.buffer(4)
	.subscribe(it -> log.info("onNext: {}", it));
// Результат:
// onNext: [1, 2, 3, 4]
// onNext: [5, 6, 7, 8]
// onNext: [9, 10, 11, 12]
// onNext: [13]
```

```java
Flux<Flux<Integer>> windowedFlux = Flux.range(101, 20)
	.windowUntil(this::isPrime, true);
windowedFlux.subscribe(window -> window
	.collectList()
	.subscribe(it -> log.info("window: {}", it)));
// Результат:
// window: []
// window: [101, 102]
// window: [103, 104, 105, 106]
// window: [107, 108]
// window: [109, 110, 111, 112]
// window: [113, 114, 115, 116, 117, 118, 119, 120]
```

```java
Flux.range(1, 7)
	.groupBy(e -> e % 2 == 0 ? "Even" : "Odd")
	.subscribe(groupFlux -> groupFlux
		.scan(new LinkedList<>(), (list, elem) -> {
			list.add(elem);
			if(list.size() > 2) {
				list.remove(0)
			}
			return list;
		})
		.filter(arr -> !arr.isEmpty())
		.subscribe(it -> log.info("{}: {}", groupFlux.key(), data)));
// Результат:
// Odd: [1]
// Even: [2]
// Odd: [1, 3]
// Even: [2, 4]
// Odd: [3, 5]
// Even: [4, 6]
// Odd: [5, 7]
```
### Операторы flatMap, concatMap, и flatMapSequential
`flatMap` - преобразует каждый входящий элемент в реактивный поток, затем сливает сгенерированные реактивные последовательности в новую реактивную последовательность.
![[Pasted image 20240208213338.png]]
Операторы flatMap, concatMap, flatMapSequential имеют следующие отличия друг от друга:
- по-разному подписываются на внутренние потоки - `flatMap` и `flatMapSequential` подписываются сразу на все потоки, а `concatMap` ждет завершения очередного внутреннего потока, прежде чем сгенерировать следующий и подписаться на него;
- генерируют элементы в разном порядке - `concatMap` естественным образом сохраняет исходный порядок элементов, `flatMapSequential` сохраняет исходный порядок элементов, полученных не по порядку, сохраняя их в очереди, а `flatMap` не гарантирует сохранение исходного порядка элементов;
- по-разному перемежают элементы из разных потоков - оператор `flatMap` допускает смешивание элементов из разных потоков, когда как операторы `concatMap` и `flatMapSequential` - нет;
```java
// из первого потока элементы идут не по порядку,
// пока генерируется первая книга для первого пользователя
// зайти в метод генерации успевают все пользователи
// так же работает и с послдующими книгами
Flux.just("user-1", "user-2", "user-3")  
       .flatMap(user -> requestBook(user)  
             .map(book -> user + "/" + book))  
       .subscribe(info -> log.info("onNext: {}", info));
       
private Flux<String> requestBook(String user) {  
    return Flux.range(1, rnd.nextInt(3) + 1)  
          .map(it -> "book-" + it)  
          .delayElements(Duration.ofMillis(3));  
}
// Результат:
// onNext: user-2/book-1
// onNext: user-1/book-1
// onNext: user-3/book-1
// onNext: user-2/book-2
// onNext: user-1/book-2
// onNext: user-3/book-2
// onNext: user-3/book-3
```

Библиотека позволяет задерживать сигналы onError с помощью операторов `flatMapDelayError`, `flatMapSequentialDelayError` и `concatMapDelayError`. `concatMapIterable` дает возможность выполнить аналогичную операцию, когда функция преобразования генерирует не реактивный поток, а итератор для каждого элемента, в таком случае перемежения элементов не происходит.
### Извлечение выборки элементов
Когда требуется высокая пропускная способность, иногда имеет смысл обрабатывать только часть событий, применяя прием извлечения выборки. Для этого Reactor предлагает операторы sample и sampleTimeout. То есть из последовательности можно периодически извлекать отдельные элементы, соответствующие последнему значению, наблюдавшемуся во временном окне.
```java
Flux.range(1, 100)  
       .delayElements(Duration.ofMillis(1))  
       .sample(Duration.ofMillis(20))  
       .subscribe(it -> log.info("onNext: {}", it));
// Результат:
// onNext: 15
// onNext: 29
// onNext: 43
// onNext: 58
// onNext: 74
// onNext: 89
// onNext: 100
```
### Преобразование реактивных последовательностей в блокирующие структуры
- `toIterable` преобразует реактивный поток `Flux` в блокирующую структуру `Iterable`;
- `toStream` преобразует реактивный поток `Flux` в блокирующий `Stream API`;
- `blockFirst` блокирует текущий поток выполнения, пока входящий поток данных не передаст первое значение или не завершится;
- `blockLast` блокирует текущий поток выполнение, пока входящий поток данных не передаст последнее значение или не завершится. В случае сигнала `onError` возбудит исключение в заблокированном потоке выполнения.
`blockFirst` и `blockLast` имеют перегруженные версии с параметром предельного времени блокировки, чтобы избежать блокировки потока навечно. `toIterable` и `toStream` могут использовать очередь `Queue` для сохранения событий, если они поступают быстрее, чем клиент успевает выполнять блокирующие итерации с `Iterable` или `Stream`.
### Просмотре элементов при обработке последовательности
| Метод                                            | Описание                                                                          |
| ------------------------------------------------ | --------------------------------------------------------------------------------- |
| `doOnNext`                                       | позволяет выполнить действие с каждым элементом в потоке данных Flux или Mono     |
| `doOnComplete`                                   | вызывается в обработчике onComplete                                               |
| `doOnError`                                      | вызывается в обработчике onError                                                  |
| `doOnSubscribe`<br>`doOnRequest`<br>`doOnCancel` | позволяют определить реакцию на события жизненного цикла подписки                 |
| `doOnTerminate`                                  | вызывается с завершение потока данных независимо от причины, вызвавшей завершение |
| `doOnEach`                                                 | обрабатывает все сигналы реактивного потока - `onError`, `onSubscribe`, `onNext`, `onComplete`                                                                                  |
```java
Flux.just(1, 2, 3)
	.concatWith(Flux.error(new RuntimeException("error")))
	.doOnEach(s -> log.info("signal: {}", s))
	.subscribe();

// Результат:
// signal: doOnEach_onNext(1)
// signal: doOnEach_onNext(2)
// signal: doOnEach_onNext(3)
// signal: onError(java.lang.RuntimeException: error)
```
### Материализация и дематериализация сигналов
Методы `materialize` и `dematerialize` позволяют преобразовывать данные последовательностей в сигналы и обратно.
### Фабричные методы push и create
`push` позволяет программно создать экземпляр `Flux` на основе однопоточного производителя, этот подход можно использовать для адаптации асинхронного, однопоточного многозначного API, не заботясь об управлении обратным давлением или отмене подписки:
```java
Flux.push(e -> IntStream
		.range(2000, 3000)
		// элементы передаются объекту e типа FluxSink
		.forEach(it -> e.next(it)))
	.delayElements(Duration.ofMillis(1))
	.subscribe(e -> log.info("onNext: {}", e));
```
 `create` действует подобно `push`, но дополнительно позволяет пересылать события из разных потоков выполнения, сериализуя экземпляр `FluxSink`. Оба метода допускают переопределение стратегии реакции на переполнение и освобождение ресурсов путем регистрации дополнительных обработчиков.
 ```java
 Flux.create(emitter -> {
	 emitter.onDispose(() -> log.info("Dispose"));
	 // отправить события объекту emitter
 })
 .subscribe(e -> log.info("onNext: {}", e))
```
### Фабричный метод generate
`generate`  дает возможность генерировать сложные последовательности на основе внутреннего состояния генератора. Он требует передачи начального значения и функции, вычисляющей следующее внутреннее состояние на основе предыдущего, и посылает сигнал `onNext` подписчику на исходящий поток.
```java
Flux.generate(() -> Tuples.of(0L, 1L),
		   (state, sink) -> {
			   log.info("generated value: {}", state.getT2());
			   sink.next(state.getT2());
			   long newValue = state.getT1() + state.getT2();
			   return Tuples.of(state.getT2, newValue);
		   })
	.delayElements(Duration.ofMillis(1))
	.take(7)
	.subscribe(e -> log.info("onNext: {}", e));
```
### Передача одноразовых ресурсов в реактивные потоки
`using` создает поток данных, использующий одноразовые ресурсы, реализует семантику `try-with-resources` в реактивном программировании.  using имеет перегрузку, с параметром позволяющим выбрать до или после уведомления подписчика о завершении потока будет вызвана очистка ресурсов.
Императивный стиль:
```java
try (final var connection = Connection.newConnection()) {  
    connection.getData()
	    .forEach(d -> log.info("Data: {}", d));  
} catch (Exception e) {  
    log.warn("Error: {}", e.getMessage());  
}
```
Реактивный стиль:
```java
Flux.using(  
       Connection::newConnection,  
       connection -> Flux.fromIterable(connection.getData()),  
       Connection::close  
).subscribe(  
       d -> log.info("Data: {}", d),  
       e -> log.warn("Error: {}", e.getMessage()),  
       () -> log.info("Stream finished"));
```
### Обертывание транзакций с помощью фабричного метода usingWhen
usingWhen позволяет управлять ресурсами, в отличие от using, `оператор` `usingWhen` получает ресурс реактивно (подписавшись на экземпляр `Publisher`). Кроме того, оператор `usingWhen` принимает разные обработчики для событий успешного или неудачного завершения обработки главного потока данных. Эти обработчики реализуются издателями. Данное отличие помогает реализовать неблокирующие реактивные транзакции одним оператором.
```java
Flux.usingWhen(  
	  // асинхронное создание новой транзакции
       Transaction.beginTransaction(),  
       // попытка вставить новые данные в рамках транзакции
       transaction -> transaction.insertRows(Flux.just("A", "B", "C")),  
       // если все ок - подтверждаем
       Transaction::commit,  
       // если нет -  откатываем
       Transaction::rollback,  
       // закрываем транзакцию
       Transaction::closeAsync  
).subscribe(  
       d -> log.info("onNext: {}", d),  
       e -> log.info("onError: {}", e.getMessage()),  
       () -> log.info("onComplete")  
);
```
### Обработка ошибок
Варианты реагирования на исключение:
- обработчик сигнала `onError` должен быть определен в операторе `subscribe`;
- `onErrorReturn` перехватывает и подменяет ошибку статическим значением по умолчанию или значением, вычисленным по основе исключения;
- `onErrorResume` перехватывает исключение и выполняет альтернативную процедуру;
- `onErrorMap` перехватывает исключение и преобразовывает его в другое исключение;
- `retry` создаст повторную подписку на источник реактивной последовательности, если тот сообщит об ошибке. Он может повторять попытки до бесконечности или ограничиться некоторым интервалом времени. Оператор `retryBackoff` предлагает готовую поддержку экспоненциальной задержки, который постепенно увеличивает задержки между повторными попытками;
Варианты реагирования на пустой поток:
- `defaultIfEmpty` возвращает значение по умолчанию;
- `switchIfEmpty` запускает другой поток данных;
Оператор `timeout` позволяет ограничить период ожидания и возбудить исключение `TimeoutException`.

```java
Flux.just("user-1")
	.flatMap(user -> someMethod(user)
		// если вызов терпит неудачу, повторяем попытки
		// постепенно увеличивая задержку
		// попыток не больше 5, 
		// задержки начинаются с 100мл
		.retryBackoff(5, Duration.ofMillis(100))
		// если стратегия повторных попыток не дала
		// результат спустя 3 секунды, 
		// генерируем сигнало ошибки
		.timeout(Duration.ofSeconds(3))
		// преобразуем ошибку в значение по умолчанию
		.onErrorResume(e -> Flux.just("default val")))
	.subscribe(
		it -> log.info("onNext: {}", it),
		ex -> log.warn("onError: {}", ex.getMessage()),
		() -> log.info("onComplete")
	);
```
### Управление обратным давлением
Можно настроить обработку обратного давления в потоке данных, используя следующие инструменты:
- onBackPressureBuffer запрашивает неограниченный объем данных и передает получаемые элементы в нисходящий поток, если потребитель нисходящего потока не справляется с нагрузкой, он сохраняет элементы в очереди;
- onBackPressureDrop запрашивает неограниченный объем данных и переделает получаемые элементы в нисходящий поток. Если потребитель нисходящего потока не справляется с нагрузкой, оператор отбрасывает элементы. Такие отбрасываемые элементы можно обрабатывать с помощью дополнительного обработчика;
- onBackPressureLast действует подобно onBackPressureDrop, но сохраняет последний отброшенный элемент и передает его в нисходящий поток, как только появится возможность. Таким способом всегда можно получить самый последний элемент - даже в ситуации переполнения;
- onBackPressureError запрашивает неограниченный объем данных и пытается передать их в нисходящий поток. Если потребитель нисходящего потока не справляется с нагрузкой. оператор возбуждает ошибку;
Оператор limitRate(n) разбивает запрошенный снизу объем данных на пакеты с размером не больше n. 
Оператор limitRequest(n) позволяет ограничить количество запрашиваемых элементов со стороны потребителя. После отправки n элементов оператор закроет поток данных.
### Горячие и холодные потоки данных
Холодный издатель генерирует последовательность данных **только** при появлении подписчика (`defer`). Горячий издатель генерирует данные независимо от наличия подписчиков (`just`).
### Широковещательная рассылка элементов потока данных
Класс `ConnectableFlux` способен немедленно рассылать данные быстрым подписчикам и кешировать их для остальных, чтобы все могли обрабатывать данные в удобном для себя темпе. Размер очереди и тайм-ауты настраиваются с помощью методов publish и replay этого класса. Также `ConnectableFlux` может автоматически отслеживать число подписчиков и инициировать выполнение по достижении установленного порога при вызове методов `connect`, `autoConnect(n)`, `refCount(n)`, `refCount(int, Duration)`.
```java
// издатель принял подписку и сгененрировал элементы 
// только один раз, однако оба подписчика 
// получили полный набор событий
Flux<Integer> source = Flux.range(0, 3)  
       .doOnSubscribe(s -> log.info("[connect] new subscriber"));  
ConnectableFlux<Integer> conn = source.publish();  
conn.subscribe(e -> log.info("[sub 1] onNext: {}", e));  
conn.subscribe(e -> log.info("[sub 2] onNext: {}", e));  
log.info("all subscribers are ready");  
conn.connect();
```
### Кэширование элементов
Оператор `cache` - внутри использует `ConnectableFlux`, позволяет реализовать разные стратегии кэширования данных.
```java
// создается холодный издатель
Flux<Integer> source = Flux.range(0, 2)  
       .doOnSubscribe(e -> log.info("[cache] new subscriber"));  
// производится кеширование издателя на 1 секунду
Flux<Integer> conn = source.cache(Duration.ofSeconds(1));
// подключаются 2 подписчика
conn.subscribe(e -> log.info("[sub 1] onNext: {}", e));  
conn.subscribe(e -> log.info("[sub 2] onNext: {}", e));  
Thread.sleep(1200);  
// после дилея в 1.2 секунды подключается третий подписчик
conn.subscribe(e -> log.info("[sub 3] onNext: {}", e));
// первые два подписчика получат одни данные, третий подписчик не успеет получить закешированные данные, поэтому будет содана новая подписка для холодного издателя
```
### Совместное использование элементов из потока
Оператор `share` преобразует холодного издателя в горячего.
```java
Flux<Integer> source = Flux.range(0, 5)  
       .delayElements(Duration.ofMillis(100))  
       .doOnSubscribe(e -> log.info("[share] new subscriber"));  
Flux<Integer> conn = source.share();  
conn.subscribe(e -> log.info("[sub 1] onNext: {}", e));  
Thread.sleep(400);  
conn.subscribe(e -> log.info("[sub 2] onNext: {}", e));
// результат
// [sub 1] onNext: 0
// [sub 1] onNext: 1
// [sub 1] onNext: 2
// [sub 1] onNext: 3
// [sub 2] onNext: 3
// [sub 1] onNext: 4
// [sub 2] onNext: 4
```
### Работа со временем
Оператор `elapsed` отмеряет интервал времени от предыдущего события.
```java
Flux.range(0, 5)  
	.delayElements(Duration.ofMillis(100))  
	.elapsed()
	.subscribe(e -> log.info("Elapsed {} ms: {}", e.getT1(), e.getT2()));
// Результат
// Elapsed 151 ms: 0 
// Elapsed 105 ms: 1 
// Elapsed 105 ms: 2 
// Elapsed 103 ms: 3 
// Elapsed 102 ms: 4	
```
Интервал между события выдерживается не точно, это вызвано тем, что `Project Reactor` использует `ScheduledExecutorService` для планирования событий.
### Компановка и преобразование реактивных потоков
Оператор `transform` позволяет применять к потоку функцию (последовательность операторов). `transform` меняет поведение потока 1 раз, на этапе сборки.
```java
Function<Flux<String>, Flux<String>> func = ...;
Flux.range(1000, 3)
	.transform(func)
	.subscribe(e -> log.info("onNext: {}", e));
```
Оператор `compose` аналогичен `transform`, но преобразовывает поведение потока при появлении каждого нового подписчика.
```java
Function<Flux<String>, Flux<String>> func = ...;
Flux<Integer> flux =Flux.range(1000, 3)
	.compose(func);
flux.subscribe(e -> log.info("[sub 1] onNext: {}", e));
flux.subscribe(e -> log.info("[sub 2] onNext: {}", e));
```
### Процессоры
`Processor` одновременно является издателем `Publisher`, и подписчиком `Subscriber`. Т.е. можно подписаться на Processor события, генерируемые экземпляром `Processor`, и передавать ему свои сигналы. Данное API не рекомендуется к использования, из-за сложности в применении.
Reactor предлагает следующие виды процессоров:
- **непосредственные** (`DirectProcessor`, `UnicastProcessor`) процессоры могут посылать данные только вручную, работая с получателем.
- **синхронные**  (`EmitterProcessor`, `ReplayProcessor`) процессоры могут посылать данные и вручную, и по подписке на вышестоящего издателя.
- **асинхронные** (`WorkQueueProcessor`, `TopicProcessor`) процессоры могут пересылать данные вниз, получая их от нескольких вышестоящих издателей.
## Продвинутые средства в Project Reactor
### Жизненный цикл реактивных потоков
| Этап       | Описание                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| ---------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Сборка     | Конструирование конвейеров обработки элементов происходит без изменения имеющихся объектов. Каждый применяемый оператор создает новый объект. После процесса сборки получается цепочка издателей `Publisher`, в которой каждый последующий обертывает предыдущего (`Flux1(Flux2(Flux3(1,2,...,n)))`). <br>В ходе этого этапа мы можем манипулировать конструкцией потока данных и применять разные приемы для оптимизации, мониторинга или отладки потока, которые являются неотъемлемой частью реактивной системы. |
| Подписка   | Происходит в момент, когда мы подписываемся на получение данных от заданного издателя Publisher. Подписываясь на самого внешнего издателя, запускается процесс подписки в цепочке издателей.<br>`Subscriber3(Subscriber2(Subscriber1(Subscriber)))`<br>На этой стадии можно выполнить те же оптимизации, что и на этапе сборки. Некоторые операторы, поддерживающие многопоточное выполнение в Reactor, позволяют изменить поток выполнения, в котором происходит подписка.                                         |
| Выполнение | В ходе этого этапа происходит фактический обмен сигналами между издателем и подписчиком. Метод `onSubscribe` вызывается источником самого верхнего уровня. Он передает свой экземпляр Subscription указанному подписчику Subscriber. После того как подписка будет передана всем подписчикам в цепочке и каждый подписчик упакует ее в конкретное представление, мы получим пирамиду подписок `Subscription1(Subscription2(Subscription1()))`.<br>Когда последний подписчик получит цепочку подписок, он должен вызвать метод `Subscription#request`, чтобы начать получать элементы. Когда все подписчики передадут запрошенное количество элементов и можно начать передавать элементы в цепочку.<br>В процессе выполнения элемент из источника проходит через цепочку подписчиков, и каждый выполняет определенные действия.<br>В процессе выполнения этапа можно применять оптимизации, сокращающие обмен сигналами.                                                                                                                       |
![[Pasted image 20240217234329.png]]
### Модель планирования потоков выполнения в Reactor
В Reactor можно управлять потоками выполнения, для этого существует 4 оператора.
#### Scheduler (планировщик)
`Scheduler` - интерфейс, представляющий рабочий поток или пул рабочих потоков, используется для выбора рабочего потока с  целью обработки элементов потока данных. Определяет два основных метода:
- `Scheduler.schedule` - позволяет запланировать задание Runnable;
- `Scheduler.createWorker` -  возвращаяет выделенный экземпляр интерфейса `Worker`, который некоторым образом планирует задания `Runnable`.
`Scheduler` представляет пул рабочих потоков, а `Worker` - выделенная абстракция потока выполнения Thread или некоторого ресурса.
По умолчанию Reactor предлагает 3 основных реализации интерфейса `Scheduler`:
- `SingleScheduler` позволяет запланировать все возможные задания в одном выделенном рабочем потоке. Поддерживает планирование с учетом времени, поэтому может использоваться для планирования периодических событий с задержкой. Сослаться на этот планировщик можно вызовом `Schedulers.single()`;
- `ParallelScheduler` работает с пулом рабочих потоков фиксированного размера. Способен планировать события во времени. Сослаться на этот планировщик можно вызовом `Scheduler.parallel()`;
- `ElasticScheduler` динамически создает рабочие потоки и кеширует полы потоков выполнения. Максимальное число создаваемых пулов потоков выполнения не ограничивается. Сослаться на этот планировщик можно вызовом `Schedulers.elastic()`;
#### Контекст
Context дает доступ к некоторой контекстной информации в многопоточной среде. Экземпляры контекста передаются вместе с потоком данных. Контекст может быть разным в разных точках потока, так как идет снизу в верх (так как происходит в момент подписки).
```java
final var header = "x-request-id";  
Flux.range(0, 10)  
       .flatMap(it -> Mono.deferContextual(ctx -> Mono.just(ctx.get(header))))  
       .contextWrite(Context.of(header, UUID.randomUUID()))  
       .parallel(10)  
       .runOn(Schedulers.parallel())  
       .doOnNext(it -> log.info("onNext: {}", it))  
       .subscribe();
```

#### Оператор publishOn
`publishOn` позволяет перенести этап выполнения потока данных в конкретный рабочий поток.
```java
Scheduler scheduler = ...;
Flux.range(0, 100)
	.map(String::valueOf) // гланый поток выполнения
	.publishOn(scheduler) // перенос
	.map(it -> someLogic(it)) // поток выполнения
	.subscribe();
```
Оператор `publishOn` охватывает этап выполнения. Внутри оператора имеется очередь, куда записываются новые элементы, чтобы выделенный рабочий поток мог последовательно извлекать сообщения из очереди и обрабатывать их.
Все элементы в реактивном потоке обрабатываются последовательно (не конкурентно), благодаря чему всегда можно определить точный порядок следования событий.
#### Оператор subscribeOn
`subscribeOn` позволяет изменить рабочий поток выполнения, в котором выполняется часть цепочки, относящаяся к подписке. Может пригодиться для создания источника данных, основанного на применении функции, так как создание происходит в момент подписки и не может быть настроена оператором `publishOn`.
```java
Scheduler scheduler = ...;
Mono.fromCallable(...) // произойдет в настроеном потоке
	.subscribeOn(scheduler)
	.subscribe();
```
`subscribeOn` в какой-то мере может определять рабочий поток для этапа выполнения наряду с рабочим потоком для этапа подписки. Это возможно, потому что наряду с планированием выполнения метода subscribe он планирует каждый вызов метода `Subscription.request()`, то есть это происходит в рабочем потоке выполнения, который определит экземпляр `Scheduler`.
#### Оператор parallel
`parallel` позволяет разбить один поток данных на несколько подпотоков и распределить элементы между ними.
После применения оператора parallel мы начинаем работать с `ParallelFlux` (абстракция группы экземпляров `Flux`, между которыми распределяются элементы из исходного потока `Flux`).
```java
Flux.range(0, 1000)  
       .parallel()  
       .runOn(Schedulers.parallel())  
       .doOnNext(it -> log.info("onNext: {}", it))  
       .subscribe();
```
## Реактивность в Spring Core
### Поддержка преобразования реактивных типов
Позволяет преобразовывать реактивные типы данных, упрощает взаимодействие с альтернативными реактивными библиотеками.
```java
public class ReactiveAdapter {
	<T> Publisher<T> toPublisher(@Nullable Object obj) {
		...
	}
	Object fromPublisher(Publisher<?> publisher) {
		...
	}
}
```
### Реактивный ввод/вывод
`DataBuffer` -  абстракция над буфером байтов, необходима для поддержки разных буферов байтов без необходимости выполнять любые преобразования между ними.
```java
Flux<DataBuffer> reactiveHamlet = DataBufferUtils.read(
	new DefaultResourceLoader().getResource("test.txt"), 
	new DefaultDataBufferFactory(),  
	1024
);
```
### Реактивные кодеки
Реактивные кодеки дают удобную возможность преобразования потока экземпляров `DataBuffer` в поток объектов и обратно.
```java
interface Encoder<T> { 
	...
	Flux<DataBuffer> encode(Publisher<? extends T> inputStream, ...); 
}
```

```java
interface Decoder<T> { 
	...
	Flux<T> decode(Publisher<DataBuffer> inputStream, ...);
	Mono<T> decodeToMono(Publisher<DataBuffer> inputStream, ...); 
}
```
## Реактивная безопасность
Для доступа к `SecurityContext` в реактивном модуле **Spring Security** имеется класс `ReactiveSecurityContextHolder`.
```java
@RestController
@RequestMapping("api/v1/")
public class Controller {
	@GetMapping("profiles")
	@PreAuthorize("hasRole('USER')")
	public Mono<Profile> getProfile() {
		return ReactiveSecurityContextHolder
			.getContext()
			.map(it -> it.getAuthentication())
			.flatMap(it -> service.getProfile(it.getName()))
	} 
}
```
